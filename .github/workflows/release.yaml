# .github/workflows/go-cross-compile.yml

name: Go Cross-Compile and Release

# This workflow will run on:
# 1. Every push to the 'main' branch (useful for testing builds)
# 2. When a new GitHub Release is published (to create and attach release assets)
on:
  push:
    branches:
      - main # Or 'master', depending on your default branch name
  release:
    types: [published]

jobs:
  # Job to build the Go application for various platforms
  build:
    name: Build ${{ matrix.os }}/${{ matrix.arch }}
    runs-on: ubuntu-latest # Use an Ubuntu runner for consistent build environment

    strategy:
      # Define a matrix of operating systems and architectures to build for
      matrix:
        os: [linux, windows, darwin]
        arch: [amd64, arm64]
        # Exclude unsupported or less common combinations to speed up builds
        exclude:
          # Windows ARM64 cross-compilation can be more complex, often requiring specific SDKs or CGO considerations.
          # If your app needs this, you might need a more specialized build step.
          - os: windows
            arch: arm64
          # Older 32-bit architectures are often not needed, but can be added if required
          - os: linux
            arch: 386
          - os: darwin
            arch: 386

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Action to check out your repository code

      - name: Set up Go environment
        uses: actions/setup-go@v5 # Action to set up the Go toolchain
        with:
          go-version: "1.22" # Specify the Go version you want to use (e.g., '1.22' or 'stable')

      - name: Build Go application
        run: |
          # Set environment variables for cross-compilation
          export GOOS=${{ matrix.os }}    # Target Operating System
          export GOARCH=${{ matrix.arch }} # Target Architecture

          # Define the output filename based on OS and architecture
          # Windows executables typically have a .exe extension
          BINARY_NAME="my-app-${{ matrix.os }}-${{ matrix.arch }}"
          if [ "${{ matrix.os }}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          # Build the Go application
          # CGO_ENABLED=0 disables CGO, which simplifies cross-compilation if your Go app
          # does not rely on C libraries. If it does, you might need a more complex setup
          # or a dedicated cross-compiler toolchain for C.
          echo "Building for $GOOS/$GOARCH..."
          CGO_ENABLED=0 go build -o "$BINARY_NAME" ./main.go

          # Verify the built binary (list its size and permissions)
          echo "Built binary details:"
          ls -lh "$BINARY_NAME"

      - name: Upload compiled binary as artifact
        uses: actions/upload-artifact@v4 # Action to upload build artifacts
        with:
          # The name of the artifact will include the OS and architecture
          name: my-app-${{ matrix.os }}-${{ matrix.arch }}
          # The path to the binary. Use a wildcard for the .exe extension on Windows.
          path: my-app-${{ matrix.os }}-${{ matrix.arch }}*

  # Job to create a GitHub Release and upload the compiled binaries as assets
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest # Use an Ubuntu runner
    needs: build # This job depends on the 'build' job completing successfully
    # This job will only run when a new GitHub Release is published
    if: github.event_name == 'release' && github.event.action == 'published'

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4 # Action to download artifacts from previous jobs
        with:
          path: artifacts # Download all artifacts into an 'artifacts' directory

      - name: List downloaded artifacts (for debugging purposes)
        run: ls -R artifacts

      - name: Create GitHub Release
        id: create_release # Assign an ID to this step to reference its outputs
        uses: actions/create-release@v1 # Action to create a new GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN is automatically provided by GitHub Actions
        with:
          tag_name: ${{ github.ref }} # Use the Git tag that triggered the release
          release_name: Release ${{ github.ref }} # Name of the release
          draft: false # Set to true if you want to create a draft release first
          prerelease: false # Set to true if this is a pre-release

      - name: Upload Release Assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN for authentication
        run: |
          # Iterate over each downloaded artifact directory (e.g., artifacts/my-app-linux-amd64/, artifacts/my-app-windows-amd64/)
          for dir in artifacts/*/; do
            # Find the actual binary file within each directory
            # The find command ensures we get the correct path, including the .exe extension for Windows
            BINARY_PATH=$(find "$dir" -type f -name "my-app-*")

            # Check if a binary file was found
            if [ -f "$BINARY_PATH" ]; then
              # Extract just the filename (e.g., my-app-linux-amd64 or my-app-windows-amd64.exe)
              BINARY_FILENAME=$(basename "$BINARY_PATH")

              echo "Uploading asset: $BINARY_FILENAME from $BINARY_PATH"

              # Use curl to upload the binary as a release asset
              # The upload_url comes from the output of the 'create_release' step
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Content-Type: application/octet-stream" \
                --data-binary "@$BINARY_PATH" \
                "${{ steps.create_release.outputs.upload_url }}?name=$BINARY_FILENAME"
            else
              echo "Warning: No binary found in $dir. Skipping upload for this artifact."
            fi
          done
